"""
CLI/GUI tool for calibrating Waters .MzML files, and fixing
misformed files generated by Xevo MRT

Usage: waters_mzml_tools --help
"""

from PyQt5.QtWidgets import QApplication
import pyopenms as oms

import src.calibration as calibration
import src.gui_mode as gui_mode
import src.file_utils as file_utils
from src.waters_utils import fix_missing_ms_level_labels
from src.calibration_utils import remove_lockmass_scans

import sys
import argparse
import json
from pathlib import Path
from typing import Optional, TYPE_CHECKING
if TYPE_CHECKING:
    from pyqtgraph import GraphicsLayoutWidget

def _setup_parser() -> argparse.ArgumentParser:
    """
    Set up parser for CLI use
    """
    # parser: argparse.ArgumentParser = argparse.ArgumentParser(
    parser: argparse.ArgumentParser = argparse.ArgumentParser(
        description='Tool for manually calibrating Waters .mzML files. '
                    'Can also be used to fix mis-formed .mzML files generated by '
                    'Xevo MRT instruments',
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    # Arguments:
    parser.add_argument(
        '--gui',
        help='Launch GUI mode. All subsequent arguments will be ignored',
        action='store_true',
    )

    parser.add_argument(
        '--input', '-i',
        help='Input .mzML file, or alternatively, a report .JSON file. '
             'If a .json file is passed, will display calibration plots '
             'If this argument is not given, the program launches in GUI mode.',
        type=str,
        default=None,
    )

    parser.add_argument(
        '--experiment-type',
        help='Type of experiment ("dda" or "dia"). '
             'Note: dda not yet implemented',
        choices=['dda', 'dia'],
        default='dia',
    )

    parser.add_argument(
        '--add-ms-levels',
        help='Add MS level tags based on the spectra native IDs. '
        'This is needed because converting XMRT data into .RAW then .mzML '
        'strips out MS level information',
        action='store_true',
    )

    output_group = parser.add_argument_group(
        "Output Directory",
    )
    output_group.add_argument(
        '--output',
        help='(Optional) Select directory to save output. If not provided, will '
             'save output files in same directory with a different name',
        default=None,
    )

    calibration_group = parser.add_argument_group(
        "Calibration",
        "Calibrate .mzML file using lockmass scans"
    )

    calibration_group.add_argument(
        '--calibrants', '-c',
        help='If provided, applies calibration. Specifies location of .txt '
             'file containing calibrant m/z values or formulae',
        type=str,
        default=None,
    )

    calibration_group.add_argument(
        '--formulae', '-f',
        help='Calibrant list contains formulae rather than m/z values. If this flag is provided, '
             'the program will calculate the expected m/z values. Remember to include charge.',
        action='store_true',
    )

    calibration_group.add_argument(
        '--calibrant-window', '-cw',
        help='The window (in Da) for which to search for a calibrant signal. '
             'Default is 0.1',
        type=float,
        default=0.1,
    )

    calibration_group.add_argument(
        '--calibrant-min-intensity', '-ci',
        help='The minimum signal intensity at which a calibrant is considered. '
             'Default is 1e3',
        type=float,
        default=1e3,
    )

    parser.add_argument(
        '--remove-calibration-scans',
        help='Removes the "lockmass" scans from final output',
        action='store_true'
    )

    calibration_group.add_argument(
        '--show-calibration-plot',
        help='Show a calibration plot after correcting the .mzML file',
        action='store_true',
    )

    return parser


def process_mzml_file_cli(
    input_path: Path,
    args: argparse.Namespace,
):
    # Load .mzML file to memory
    exp: oms.MSExperiment = file_utils.read_mzml(
        input_path=input_path,
    )

    # Initialize empty MSExperiment
    adjusted_exp = oms.MSExperiment()

    # Adjust MS levels if requested
    if args.add_ms_levels:
        print('Adding ms levels..')
        adjusted_exp: oms.MSExperiment = fix_missing_ms_level_labels(
            ms_experiment=exp,
            experiment_type=args.experiment_type,
        )

    # Calibrate MS spectra if requested
    if args.calibrants:
        # Load calibrant series
        calibrant_series: list[float] = file_utils.load_calibrant_series(
            file_path=Path(args.calibrants),
            formulae=args.formulae,
        )

        uncorrected_spectra = adjusted_exp.getSpectra()

        # Apply calibration (first pass)
        first_pass_corrected_spectra = calibration.correct_ms_exp_first_pass(
            spectra=adjusted_exp.getSpectra(),
            calibrant_series=calibrant_series,
            calibrant_window_da=args.calibrant_window,
            min_intsy=args.calibrant_min_intensity,
        )

        # Apply calibration (second pass)
        # TODO: Expose spline_k and smoothing factor
        second_pass_corrected_spectra, spline = calibration.correct_ms_exp_second_pass(
            spectra=first_pass_corrected_spectra,
            calibrant_series=calibrant_series,
            calibrant_window_da=args.calibrant_window,
            min_intsy=args.calibrant_min_intensity,
        )

        final_spectra = second_pass_corrected_spectra

        # Write calibration report
        report = calibration.generate_calibration_report(
            uncorrected_spectra=uncorrected_spectra,
            corrected_spectra_first_pass=first_pass_corrected_spectra,
            corrected_spectra_secnd_pass=second_pass_corrected_spectra,
            calibrants=calibrant_series,
            window_da=args.calibrant_window,
            min_intsy=args.calibrant_min_intensity,
            spline=spline,
        )

        if args.remove_calibration_scans:
            print('Removing calibration scans..')
            final_spectra = remove_lockmass_scans(second_pass_corrected_spectra)

        adjusted_exp.setSpectra(final_spectra)

    if args.output:
        output_dir = Path(args.output)
        if not output_dir.is_dir():
            print("Not a directory..")
            raise NotADirectoryError

        output_dir.mkdir(exist_ok=True)
        output_filepath = output_dir / f"{input_path.name}"
        report_filepath = output_dir / f"{input_path.stem}_calibration_report.json"

    else:
        # If user doesn't provide output directory,
        # save in the same directory as input files
        input_dir = Path(input_path).parent
        output_filepath = input_dir / f"fixed_{input_path.name}"
        report_filepath = input_dir / f"{input_path.stem}_calibration_report.json"

    oms.MzMLFile().store(
        str(output_filepath.absolute()),
        adjusted_exp,
    )

    if args.calibrants:
        with open(report_filepath, "w") as f:
            json.dump(report, f)

    # If user requested plot, show it
    if args.show_calibration_plot:
        calibration.read_and_display_calibration_report(
            report_path=report_filepath
        )

    print(
        f"Saved output to: {output_filepath.absolute()}"
    )



def main():
    parser: argparse.ArgumentParser = _setup_parser()
    args: argparse.Namespace = parser.parse_args()

    if args.input and not args.gui:
        if Path(args.input).suffix.lower() == '.mzml':
            process_mzml_file_cli(
                input_path=Path(args.input),
                args=args,
            )

        if Path(args.input).suffix.lower() == '.json':
            calibration.read_and_display_calibration_report(
                report_path=Path(args.input)
            )

        return

    # If program reaches this line, launch GUI mode
    print(
        "Launching GUI mode..."
    )

    app = QApplication([])
    main_window = gui_mode.MainWindow()
    main_window.show()

    sys.exit(
        app.exec_()
    )


if __name__ == "__main__":
    main()